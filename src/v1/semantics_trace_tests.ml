open Goal
open Stream

let%expect_test "" =
  let open Examples in
  print_trace Semantics_trace.eval [ appendo ] (-1)
    (fresh [ "q" ] @@ invoke "appendo" [ list12; list3; Var "q" ]);
  [%expect
    {|
    ----------------------------------------------

    Step 0:
      No answer,
      <
        fresh (q) appendo [1; 2] [3] q,
        { },
        Var counter: 0
      >

    ----------------------------------------------

    Step 1:
      No answer,
      <
        appendo [1; 2] [3] _.1,
        { },
        Var counter: 1
      >

    ----------------------------------------------

    Step 2:
      No answer,
      mplus
        <
          [1; 2] === [] &&& [3] === _.1,
          { },
          Var counter: 1
        >
        <
          fresh (h t ab') [1; 2] === [h; t] &&& [h; ab'] === _.1 &&& appendo t [3] ab',
          { },
          Var counter: 1
        >

    ----------------------------------------------

    Step 3:
      No answer,
      <
        [1; 2] === [_.2; _.3] &&& [_.2; _.4] === _.1 &&& appendo _.3 [3] _.4,
        { },
        Var counter: 4
      >

    ----------------------------------------------

    Step 4:
      No answer,
      mplus
        bind
          mplus
            bind
              nil
              [_.2; _.4] === _.1
            nil
          appendo _.3 [3] _.4
        mplus
          <
            _.3 === [] &&& [3] === _.4,
            {
              _.1 <- [_.2; _.4];
              _.2 <- 1;
              _.3 <- [2]
            },
            Var counter: 4
          >
          <
            fresh (h t ab') _.3 === [h; t] &&& [h; ab'] === _.4 &&& appendo t [3] ab',
            {
              _.1 <- [_.2; _.4];
              _.2 <- 1;
              _.3 <- [2]
            },
            Var counter: 4
          >

    ----------------------------------------------

    Step 5:
      No answer,
      <
        _.3 === [_.5; _.6] &&& [_.5; _.7] === _.4 &&& appendo _.6 [3] _.7,
        {
          _.1 <- [_.2; _.4];
          _.2 <- 1;
          _.3 <- [2]
        },
        Var counter: 7
      >

    ----------------------------------------------

    Step 6:
      Answer:
        {
          _.1 <- [_.2; _.4];
          _.2 <- 1;
          _.3 <- [2];
          _.4 <- [_.5; _.7];
          _.5 <- 2;
          _.6 <- [];
          _.7 <- [3]
        },
        Var counter: 7,
      mplus
        bind
          mplus
            bind
              nil
              [_.5; _.7] === _.4
            nil
          appendo _.6 [3] _.7
        mplus
          <
            _.6 === [] &&& [3] === _.7,
            {
              _.1 <- [_.2; _.4];
              _.2 <- 1;
              _.3 <- [2];
              _.4 <- [_.5; _.7];
              _.5 <- 2;
              _.6 <- []
            },
            Var counter: 7
          >
          <
            fresh (h t ab') _.6 === [h; t] &&& [h; ab'] === _.7 &&& appendo t [3] ab',
            {
              _.1 <- [_.2; _.4];
              _.2 <- 1;
              _.3 <- [2];
              _.4 <- [_.5; _.7];
              _.5 <- 2;
              _.6 <- []
            },
            Var counter: 7
          >

    ----------------------------------------------

    Step 7:
      No answer,
      mplus
        <
          fresh (h t ab') _.6 === [h; t] &&& [h; ab'] === _.7 &&& appendo t [3] ab',
          {
            _.1 <- [_.2; _.4];
            _.2 <- 1;
            _.3 <- [2];
            _.4 <- [_.5; _.7];
            _.5 <- 2;
            _.6 <- []
          },
          Var counter: 7
        >
        mplus
          bind
            nil
            [3] === _.7
          nil

    ----------------------------------------------

    Step 8:
      No answer,
      mplus
        mplus
          bind
            nil
            [3] === _.7
          nil
        <
          _.6 === [_.8; _.9] &&& [_.8; _.10] === _.7 &&& appendo _.9 [3] _.10,
          {
            _.1 <- [_.2; _.4];
            _.2 <- 1;
            _.3 <- [2];
            _.4 <- [_.5; _.7];
            _.5 <- 2;
            _.6 <- []
          },
          Var counter: 10
        >

    ----------------------------------------------

    Step 9:
      No answer,
      nil |}]

let%expect_test "" =
  let open Examples in
  print_trace Semantics_trace.eval [ appendo; reverso ] (-1)
    (fresh [ "q" ] @@ invoke "reverso" [ Var "q"; list12 ]);
  [%expect
    {|
    ----------------------------------------------

    Step 0:
      No answer,
      <
        fresh (q) reverso q [1; 2],
        { },
        Var counter: 0
      >

    ----------------------------------------------

    Step 1:
      No answer,
      <
        reverso _.1 [1; 2],
        { },
        Var counter: 1
      >

    ----------------------------------------------

    Step 2:
      No answer,
      mplus
        <
          _.1 === [] &&& [1; 2] === [],
          { },
          Var counter: 1
        >
        <
          fresh (h t a') _.1 === [h; t] &&& appendo a' [h] [1; 2] &&& reverso t a',
          { },
          Var counter: 1
        >

    ----------------------------------------------

    Step 3:
      No answer,
      <
        _.1 === [_.2; _.3] &&& appendo _.4 [_.2] [1; 2] &&& reverso _.3 _.4,
        { },
        Var counter: 4
      >

    ----------------------------------------------

    Step 4:
      No answer,
      bind
        mplus
          bind
            nil
            appendo _.4 [_.2] [1; 2]
          mplus
            <
              _.4 === [] &&& [_.2] === [1; 2],
              {
                _.1 <- [_.2; _.3]
              },
              Var counter: 4
            >
            <
              fresh (h t ab') _.4 === [h; t] &&& [h; ab'] === [1; 2] &&& appendo t [_.2] ab',
              {
                _.1 <- [_.2; _.3]
              },
              Var counter: 4
            >
        reverso _.3 _.4

    ----------------------------------------------

    Step 5:
      No answer,
      bind
        <
          _.4 === [_.5; _.6] &&& [_.5; _.7] === [1; 2] &&& appendo _.6 [_.2] _.7,
          {
            _.1 <- [_.2; _.3]
          },
          Var counter: 7
        >
        reverso _.3 _.4

    ----------------------------------------------

    Step 6:
      No answer,
      bind
        mplus
          bind
            mplus
              bind
                nil
                [_.5; _.7] === [1; 2]
              nil
            appendo _.6 [_.2] _.7
          mplus
            <
              _.6 === [] &&& [_.2] === _.7,
              {
                _.1 <- [_.2; _.3];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.7 <- [2]
              },
              Var counter: 7
            >
            <
              fresh (h t ab') _.6 === [h; t] &&& [h; ab'] === _.7 &&& appendo t [_.2] ab',
              {
                _.1 <- [_.2; _.3];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.7 <- [2]
              },
              Var counter: 7
            >
        reverso _.3 _.4

    ----------------------------------------------

    Step 7:
      No answer,
      mplus
        bind
          mplus
            <
              fresh (h t ab') _.6 === [h; t] &&& [h; ab'] === _.7 &&& appendo t [_.2] ab',
              {
                _.1 <- [_.2; _.3];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.7 <- [2]
              },
              Var counter: 7
            >
            mplus
              bind
                nil
                [_.2] === _.7
              nil
          reverso _.3 _.4
        mplus
          <
            _.3 === [] &&& _.4 === [],
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2]
            },
            Var counter: 7
          >
          <
            fresh (h t a') _.3 === [h; t] &&& appendo a' [h] _.4 &&& reverso t a',
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2]
            },
            Var counter: 7
          >

    ----------------------------------------------

    Step 8:
      No answer,
      mplus
        mplus
          <
            _.3 === [] &&& _.4 === [],
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2]
            },
            Var counter: 7
          >
          <
            fresh (h t a') _.3 === [h; t] &&& appendo a' [h] _.4 &&& reverso t a',
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2]
            },
            Var counter: 7
          >
        bind
          mplus
            mplus
              bind
                nil
                [_.2] === _.7
              nil
            <
              _.6 === [_.8; _.9] &&& [_.8; _.10] === _.7 &&& appendo _.9 [_.2] _.10,
              {
                _.1 <- [_.2; _.3];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.7 <- [2]
              },
              Var counter: 10
            >
          reverso _.3 _.4

    ----------------------------------------------

    Step 9:
      No answer,
      mplus
        bind
          mplus
            mplus
              bind
                nil
                [_.2] === _.7
              nil
            <
              _.6 === [_.8; _.9] &&& [_.8; _.10] === _.7 &&& appendo _.9 [_.2] _.10,
              {
                _.1 <- [_.2; _.3];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.7 <- [2]
              },
              Var counter: 10
            >
          reverso _.3 _.4
        <
          _.3 === [_.8; _.9] &&& appendo _.10 [_.8] _.4 &&& reverso _.9 _.10,
          {
            _.1 <- [_.2; _.3];
            _.2 <- 2;
            _.4 <- [_.5; _.6];
            _.5 <- 1;
            _.6 <- [];
            _.7 <- [2]
          },
          Var counter: 10
        >

    ----------------------------------------------

    Step 10:
      No answer,
      mplus
        <
          _.3 === [_.8; _.9] &&& appendo _.10 [_.8] _.4 &&& reverso _.9 _.10,
          {
            _.1 <- [_.2; _.3];
            _.2 <- 2;
            _.4 <- [_.5; _.6];
            _.5 <- 1;
            _.6 <- [];
            _.7 <- [2]
          },
          Var counter: 10
        >
        bind
          mplus
            bind
              mplus
                bind
                  nil
                  [_.8; _.10] === _.7
                nil
              appendo _.9 [_.2] _.10
            mplus
              <
                _.9 === [] &&& [_.2] === _.10,
                {
                  _.1 <- [_.2; _.3];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [_.8; _.9];
                  _.7 <- [2];
                  _.8 <- 2;
                  _.10 <- []
                },
                Var counter: 10
              >
              <
                fresh (h t ab') _.9 === [h; t] &&& [h; ab'] === _.10 &&& appendo t [_.2] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [_.8; _.9];
                  _.7 <- [2];
                  _.8 <- 2;
                  _.10 <- []
                },
                Var counter: 10
              >
          reverso _.3 _.4

    ----------------------------------------------

    Step 11:
      No answer,
      mplus
        bind
          mplus
            bind
              mplus
                bind
                  nil
                  [_.8; _.10] === _.7
                nil
              appendo _.9 [_.2] _.10
            mplus
              <
                _.9 === [] &&& [_.2] === _.10,
                {
                  _.1 <- [_.2; _.3];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [_.8; _.9];
                  _.7 <- [2];
                  _.8 <- 2;
                  _.10 <- []
                },
                Var counter: 10
              >
              <
                fresh (h t ab') _.9 === [h; t] &&& [h; ab'] === _.10 &&& appendo t [_.2] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [_.8; _.9];
                  _.7 <- [2];
                  _.8 <- 2;
                  _.10 <- []
                },
                Var counter: 10
              >
          reverso _.3 _.4
        bind
          mplus
            bind
              nil
              appendo _.10 [_.8] _.4
            mplus
              <
                _.10 === [] &&& [_.8] === _.4,
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2]
                },
                Var counter: 10
              >
              <
                fresh (h t ab') _.10 === [h; t] &&& [h; ab'] === _.4 &&& appendo t [_.8] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2]
                },
                Var counter: 10
              >
          reverso _.9 _.10

    ----------------------------------------------

    Step 12:
      No answer,
      mplus
        bind
          mplus
            bind
              nil
              appendo _.10 [_.8] _.4
            mplus
              <
                _.10 === [] &&& [_.8] === _.4,
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2]
                },
                Var counter: 10
              >
              <
                fresh (h t ab') _.10 === [h; t] &&& [h; ab'] === _.4 &&& appendo t [_.8] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2]
                },
                Var counter: 10
              >
          reverso _.9 _.10
        bind
          <
            _.9 === [_.11; _.12] &&& [_.11; _.13] === _.10 &&& appendo _.12 [_.2] _.13,
            {
              _.1 <- [_.2; _.3];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [_.8; _.9];
              _.7 <- [2];
              _.8 <- 2;
              _.10 <- []
            },
            Var counter: 13
          >
          reverso _.3 _.4

    ----------------------------------------------

    Step 13:
      No answer,
      mplus
        bind
          <
            _.9 === [_.11; _.12] &&& [_.11; _.13] === _.10 &&& appendo _.12 [_.2] _.13,
            {
              _.1 <- [_.2; _.3];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [_.8; _.9];
              _.7 <- [2];
              _.8 <- 2;
              _.10 <- []
            },
            Var counter: 13
          >
          reverso _.3 _.4
        mplus
          bind
            mplus
              <
                fresh (h t ab') _.10 === [h; t] &&& [h; ab'] === _.4 &&& appendo t [_.8] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2]
                },
                Var counter: 10
              >
              mplus
                bind
                  nil
                  [_.8] === _.4
                nil
            reverso _.9 _.10
          mplus
            <
              _.9 === [] &&& _.10 === [],
              {
                _.1 <- [_.2; _.3];
                _.2 <- 2;
                _.3 <- [_.8; _.9];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.6 <- [];
                _.7 <- [2];
                _.8 <- 1;
                _.10 <- []
              },
              Var counter: 10
            >
            <
              fresh (h t a') _.9 === [h; t] &&& appendo a' [h] _.10 &&& reverso t a',
              {
                _.1 <- [_.2; _.3];
                _.2 <- 2;
                _.3 <- [_.8; _.9];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.6 <- [];
                _.7 <- [2];
                _.8 <- 1;
                _.10 <- []
              },
              Var counter: 10
            >

    ----------------------------------------------

    Step 14:
      Answer:
        {
          _.1 <- [_.2; _.3];
          _.2 <- 2;
          _.3 <- [_.8; _.9];
          _.4 <- [_.5; _.6];
          _.5 <- 1;
          _.6 <- [];
          _.7 <- [2];
          _.8 <- 1;
          _.9 <- [];
          _.10 <- []
        },
        Var counter: 10,
      mplus
        mplus
          <
            _.9 === [] &&& _.10 === [],
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.8 <- 1;
              _.10 <- []
            },
            Var counter: 10
          >
          <
            fresh (h t a') _.9 === [h; t] &&& appendo a' [h] _.10 &&& reverso t a',
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.8 <- 1;
              _.10 <- []
            },
            Var counter: 10
          >
        bind
          mplus
            mplus
              bind
                nil
                [_.8] === _.4
              nil
            <
              _.10 === [_.11; _.12] &&& [_.11; _.13] === _.4 &&& appendo _.12 [_.8] _.13,
              {
                _.1 <- [_.2; _.3];
                _.2 <- 2;
                _.3 <- [_.8; _.9];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.6 <- [];
                _.7 <- [2]
              },
              Var counter: 13
            >
          reverso _.9 _.10

    ----------------------------------------------

    Step 15:
      No answer,
      mplus
        bind
          mplus
            mplus
              bind
                nil
                [_.8] === _.4
              nil
            <
              _.10 === [_.11; _.12] &&& [_.11; _.13] === _.4 &&& appendo _.12 [_.8] _.13,
              {
                _.1 <- [_.2; _.3];
                _.2 <- 2;
                _.3 <- [_.8; _.9];
                _.4 <- [_.5; _.6];
                _.5 <- 1;
                _.6 <- [];
                _.7 <- [2]
              },
              Var counter: 13
            >
          reverso _.9 _.10
        mplus
          <
            fresh (h t a') _.9 === [h; t] &&& appendo a' [h] _.10 &&& reverso t a',
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.8 <- 1;
              _.10 <- []
            },
            Var counter: 10
          >
          mplus
            bind
              nil
              _.10 === []
            nil

    ----------------------------------------------

    Step 16:
      No answer,
      mplus
        mplus
          <
            fresh (h t a') _.9 === [h; t] &&& appendo a' [h] _.10 &&& reverso t a',
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.8 <- 1;
              _.10 <- []
            },
            Var counter: 10
          >
          mplus
            bind
              nil
              _.10 === []
            nil
        bind
          mplus
            bind
              mplus
                bind
                  nil
                  [_.11; _.13] === _.4
                nil
              appendo _.12 [_.8] _.13
            mplus
              <
                _.12 === [] &&& [_.8] === _.13,
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2];
                  _.10 <- [_.11; _.12];
                  _.11 <- 1;
                  _.13 <- []
                },
                Var counter: 13
              >
              <
                fresh (h t ab') _.12 === [h; t] &&& [h; ab'] === _.13 &&& appendo t [_.8] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2];
                  _.10 <- [_.11; _.12];
                  _.11 <- 1;
                  _.13 <- []
                },
                Var counter: 13
              >
          reverso _.9 _.10

    ----------------------------------------------

    Step 17:
      No answer,
      mplus
        bind
          mplus
            bind
              mplus
                bind
                  nil
                  [_.11; _.13] === _.4
                nil
              appendo _.12 [_.8] _.13
            mplus
              <
                _.12 === [] &&& [_.8] === _.13,
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2];
                  _.10 <- [_.11; _.12];
                  _.11 <- 1;
                  _.13 <- []
                },
                Var counter: 13
              >
              <
                fresh (h t ab') _.12 === [h; t] &&& [h; ab'] === _.13 &&& appendo t [_.8] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2];
                  _.10 <- [_.11; _.12];
                  _.11 <- 1;
                  _.13 <- []
                },
                Var counter: 13
              >
          reverso _.9 _.10
        mplus
          mplus
            bind
              nil
              _.10 === []
            nil
          <
            _.9 === [_.11; _.12] &&& appendo _.13 [_.11] _.10 &&& reverso _.12 _.13,
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.8 <- 1;
              _.10 <- []
            },
            Var counter: 13
          >

    ----------------------------------------------

    Step 18:
      No answer,
      mplus
        mplus
          mplus
            bind
              nil
              _.10 === []
            nil
          <
            _.9 === [_.11; _.12] &&& appendo _.13 [_.11] _.10 &&& reverso _.12 _.13,
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.8 <- 1;
              _.10 <- []
            },
            Var counter: 13
          >
        bind
          <
            _.12 === [_.14; _.15] &&& [_.14; _.16] === _.13 &&& appendo _.15 [_.8] _.16,
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.10 <- [_.11; _.12];
              _.11 <- 1;
              _.13 <- []
            },
            Var counter: 16
          >
          reverso _.9 _.10

    ----------------------------------------------

    Step 19:
      No answer,
      mplus
        bind
          <
            _.12 === [_.14; _.15] &&& [_.14; _.16] === _.13 &&& appendo _.15 [_.8] _.16,
            {
              _.1 <- [_.2; _.3];
              _.2 <- 2;
              _.3 <- [_.8; _.9];
              _.4 <- [_.5; _.6];
              _.5 <- 1;
              _.6 <- [];
              _.7 <- [2];
              _.10 <- [_.11; _.12];
              _.11 <- 1;
              _.13 <- []
            },
            Var counter: 16
          >
          reverso _.9 _.10
        bind
          mplus
            bind
              nil
              appendo _.13 [_.11] _.10
            mplus
              <
                _.13 === [] &&& [_.11] === _.10,
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2];
                  _.8 <- 1;
                  _.9 <- [_.11; _.12];
                  _.10 <- []
                },
                Var counter: 13
              >
              <
                fresh (h t ab') _.13 === [h; t] &&& [h; ab'] === _.10 &&& appendo t [_.11] ab',
                {
                  _.1 <- [_.2; _.3];
                  _.2 <- 2;
                  _.3 <- [_.8; _.9];
                  _.4 <- [_.5; _.6];
                  _.5 <- 1;
                  _.6 <- [];
                  _.7 <- [2];
                  _.8 <- 1;
                  _.9 <- [_.11; _.12];
                  _.10 <- []
                },
                Var counter: 13
              >
          reverso _.12 _.13

    ----------------------------------------------

    Step 20:
      No answer,
      bind
        <
          _.13 === [_.14; _.15] &&& [_.14; _.16] === _.10 &&& appendo _.15 [_.11] _.16,
          {
            _.1 <- [_.2; _.3];
            _.2 <- 2;
            _.3 <- [_.8; _.9];
            _.4 <- [_.5; _.6];
            _.5 <- 1;
            _.6 <- [];
            _.7 <- [2];
            _.8 <- 1;
            _.9 <- [_.11; _.12];
            _.10 <- []
          },
          Var counter: 16
        >
        reverso _.12 _.13

    ----------------------------------------------

    Step 21:
      No answer,
      nil |}]
